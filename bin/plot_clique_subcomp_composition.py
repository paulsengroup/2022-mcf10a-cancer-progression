#!/usr/bin/env python3

# Copyright (C) 2023 Roberto Rossini <roberros@uio.no>
# SPDX-License-Identifier: MIT


import argparse
import functools
import pathlib
from typing import Iterable, List, Union

import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd


def make_cli() -> argparse.ArgumentParser:
    def existing_file(arg):
        if (file := pathlib.Path(arg)).exists():
            return file

        raise FileNotFoundError(arg)

    cli = argparse.ArgumentParser(description="Plot maximal clique size distribution across conditions.")

    cli.add_argument(
        "annotated-domains",
        nargs="+",
        type=existing_file,
        help="Path to one or more TSV file with the list of annotated domains (or cliques) generated by annotate_domains_with_subcompartments.py.",
    )
    cli.add_argument(
        "-o",
        "--output-prefix",
        required=True,
        type=pathlib.Path,
        help="Path to output prefix.",
    )
    cli.add_argument(
        "--labels",
        type=str,
        help="Comma separated list of sample labels to use for plotting.\n"
        "When not provided, labels are inferred from input file names.",
    )

    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Force overwrite existing files.",
    )

    return cli


def handle_path_collisions(*paths: pathlib.Path) -> None:
    collisions = [p for p in paths if p.exists()]

    if len(collisions) != 0:
        collisions = "\n - ".join((str(p) for p in collisions))
        raise RuntimeError(
            "Refusing to overwrite file(s):\n" f" - {collisions}\n" "Pass --force to overwrite existing file(s)."
        )


def save_plot_to_file(fig: plt.Figure, outprefix: pathlib.Path, force: bool, close_after_save: bool = True) -> None:
    outprefix = pathlib.Path(outprefix)
    png = outprefix.with_suffix(".png")
    svg = outprefix.with_suffix(".svg")
    if not force:
        handle_path_collisions(png, svg)

    outprefix.parent.mkdir(exist_ok=True, parents=True)

    fig.savefig(png, bbox_inches="tight", dpi=300)
    fig.savefig(svg, bbox_inches="tight")
    if close_after_save:
        plt.close(fig)


def import_tsv(path_to_tsv: pathlib.Path, label: Union[str, None]) -> pd.DataFrame:
    if label is None:
        label = path_to_tsv.name.partition(".")[0]

    df = pd.read_table(path_to_tsv)
    df["label"] = label

    return df


@functools.cache
def get_subcompartment_ranks() -> dict:
    compartment_labels = tuple(["B3", "B2", "B1", "B0", "A0", "A1", "A2", "A3"])
    return {k: v for v, k in enumerate(compartment_labels)}


@functools.cache
def get_compartment_color_mappings() -> dict:
    compartment_labels = get_subcompartment_ranks().keys()
    colors = tuple(
        [
            "#3b4cc0ff",
            "#6788eeff",
            "#9abbffff",
            "#c9d7f0ff",
            "#edd1c2ff",
            "#f7a889ff",
            "#e26952ff",
            "#b40426ff",
        ]
    )
    return {k: v for k, v in zip(compartment_labels, colors)}


def generate_labels(paths: Iterable[pathlib.Path]) -> List[str]:
    labels = []
    for p in paths:
        labels.append(str(p.name).rstrip("".join(p.suffixes)))

    return labels


def group_by_clique_size(df):
    df1 = pd.DataFrame(index=list(get_subcompartment_ranks().keys()))

    for size, dff in df.groupby("clique_size"):
        dff = dff.groupby("state.mode").size().to_frame()
        dff.columns = ["count"]
        dff = dff[~dff.index.str.contains(",")]
        df1[size] = dff["count"]
    return df1.fillna(0).astype(int).T


def plot_composition(df: pd.DataFrame, label: str, relative: bool) -> plt.Figure:
    if relative:
        df = df.divide(df.sum(axis="columns"), axis="rows")

    fig, ax = plt.subplots(1, 1)
    df.plot(kind="bar", color=get_compartment_color_mappings().values(), stacked=True, ax=ax)

    ax.set(title=label, xlabel="Maximal clique size", ylabel="Relative coverage")
    ax.tick_params(axis="x", rotation=0)

    return fig


def main():
    args = vars(make_cli().parse_args())

    path_to_domains = args["annotated-domains"]
    labels = args.get("labels")

    if labels is None:
        labels = generate_labels(path_to_domains)
    else:
        labels = labels.split(",")

    if len(labels) != len(path_to_domains):
        raise RuntimeError(f"Expected {len(path_to_domains)} labels, found {len(labels)}")

    for domains, label in zip(path_to_domains, labels):
        df = import_tsv(domains, label)
        df = group_by_clique_size(df)
        fig = plot_composition(df, label, relative=False)

        outprefix = pathlib.Path(str(args["output_prefix"]) + f"{label}_subcomp_composition")

        save_plot_to_file(fig, outprefix, args["force"])

        fig = plot_composition(df, label, relative=True)
        save_plot_to_file(fig, pathlib.Path(str(outprefix) + "_relative"), args["force"])


if __name__ == "__main__":
    mpl.rcParams.update(
        {
            "axes.titlesize": 10,
            "axes.labelsize": 22,
            "legend.fontsize": 17,
            "xtick.labelsize": 18,
            "ytick.labelsize": 18,
        }
    )
    main()
