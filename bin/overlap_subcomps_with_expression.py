#!/usr/bin/env python3

# Copyright (C) 2023 Roberto Rossini <roberros@uio.no>
#
# SPDX-License-Identifier: MIT

import argparse
import functools
import itertools
import logging
import pathlib
import re
import warnings
from typing import Dict, Iterable, List, Tuple, Union

import bioframe as bf
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.offsetbox import AnchoredText


def make_cli():
    cli = argparse.ArgumentParser()

    def existing_file(arg):
        if (path := pathlib.Path(arg)).exists():
            return path

        raise FileNotFoundError(f'File "{arg}" does not exists')

    def comma_separated_string(s: str) -> Tuple[str]:
        return tuple(s.split(","))

    cli.add_argument(
        "bedgraph",
        type=existing_file,
        help="Path to the (sub)compartment bedGraph generated by dcHiC.",
    )

    cli.add_argument(
        "expression-table",
        type=existing_file,
        help="Path to a TSV with normalized expression levels (e.g. TPM expression levels).",
    )

    cli.add_argument(
        "gtf",
        type=existing_file,
        help="Path to a GTF with coordinates for genes found in the expression table.",
    )

    cli.add_argument(
        "output-prefix",
        type=pathlib.Path,
        help="Path to output prefix (including parent folder(s) but without extension).",
    )

    cli.add_argument(
        "--sample-name-mappings-tsv",
        type=existing_file,
        help="Path to a TSV with two columns used to rename samples found in the expression-table.\n"
        "The first column should contain the original sample name while the second column should contain the new names.",
    )

    cli.add_argument(
        "--labels",
        type=comma_separated_string,
        help="Comma-separated list of condition labels to use when plotting.\n"
        "Should be in the same order as conditions (i.e. cell types) found in the bedGraph generated by dcHiC.",
    )

    cli.add_argument(
        "--yscale",
        type=str,
        choices={"linear", "log", "symlog", "logit"},
        default="log",
        help="Set Y axis scale (i.e. scale used for TPMs)",
    )

    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Force overwrite existing files.",
    )

    return cli


@functools.cache
def get_subcompartment_ranks() -> dict:
    compartment_labels = tuple(["B3", "B2", "B1", "B0", "A0", "A1", "A2", "A3"])
    return {k: v for v, k in enumerate(compartment_labels)}


def handle_path_collisions(*paths: Union[str, pathlib.Path]) -> None:
    collisions = [p for p in paths if pathlib.Path(p).exists()]

    if len(collisions) != 0:
        collisions = "\n - ".join((str(p) for p in collisions))
        raise RuntimeError(
            "Refusing to overwrite file(s):\n" f" - {collisions}\n" "Pass --force to overwrite existing file(s)."
        )


def import_subcomps(path_to_bedgraph: pathlib.Path) -> pd.DataFrame:
    """
    Read a bedgraph into a df with the following columns:
    chrom, start, end, padj, *.state
    where *.state stores the subcompartment label for the given interval.
    """
    logging.info("Reading subcompartments from %s...", path_to_bedgraph)
    df = pd.read_table(path_to_bedgraph).rename(columns={"chr": "chrom"}).set_index(["chrom", "start", "end"])
    logging.info("Imported %d intervals", len(df))
    return df.filter(regex=".state$").rename(columns=lambda c: c.removesuffix(".state"))


def extract_attribute_gtf(data: pd.Series, key: str) -> List[str]:
    pattern = re.compile(rf"{key} \"(.*?)\";")

    return data.str.extract(pattern)


def import_gtf(path_to_gtf: pathlib.Path) -> pd.DataFrame:
    logging.info("Importing genes from GTF...")
    df = bf.read_table(path_to_gtf, schema="gtf", comment="#")
    df = df[df["feature"] == "gene"]

    for key in ["gene_id", "gene_name", "gene_type"]:
        df[key] = extract_attribute_gtf(df["attributes"], key)

    return df.drop(columns="attributes").set_index("gene_id").sort_index()


def extract_gene_types(dfs: Iterable[pd.DataFrame], gene_type_key="gene_type"):
    return np.sort(np.unique(list(itertools.chain.from_iterable((df[gene_type_key].unique() for df in dfs)))))


def import_expression_table(
    path_to_tsv: pathlib.Path, gtf: pd.DataFrame, sample_name_mappings: Dict[str, str]
) -> pd.DataFrame:
    logging.info("Importing expression table...")
    df = pd.read_table(path_to_tsv).rename(columns=sample_name_mappings)
    return (
        gtf[["chrom", "start", "end", "gene_type"]]
        .merge(
            df[df.sum(axis="columns", numeric_only=True) != 0],
            on="gene_id",
            how="right",
        )
        .set_index(["gene_id", "gene_name", "gene_type"])
        .sort_index()
    )


def import_sample_name_mappings(path_to_tsv: Union[None, pathlib.Path]) -> Dict[str, str]:
    if path_to_tsv is None:
        return {}

    df = pd.read_table(path_to_tsv, names=["src", "dest"], usecols=[0, 1]).dropna()
    return {k: v for _, (k, v) in df.iterrows()}


def overlap_genes_with_subcompartments(expression: pd.DataFrame, subcomps: pd.Series) -> pd.DataFrame:
    logging.info(f"Overlapping genes with %s subcompartments...", subcomps.name)
    # Merge adjacent intervals with identical state
    df1 = bf.merge(subcomps.rename("state").reset_index(), on=["state"]).drop(columns="n_intervals")

    cols = [col for col in expression.columns if col.startswith(subcomps.name)]
    df2 = (
        expression.reset_index()
        .set_index(["chrom", "start", "end", "gene_id", "gene_type"])[cols]
        .sum(axis="columns")
        .rename("tpm")
        .reset_index()
    )

    df3 = (
        bf.overlap(df2, df1, return_overlap=True, suffixes=("", "_2"))
        .dropna()
        .drop(columns=["chrom_2", "start_2", "end_2"])
        .rename(columns=lambda c: c.removesuffix("_2"))
    )
    df3["cov"] = (df3["overlap_end"] - df3["overlap_start"]) / (df3["end"] - df3["start"])
    df3 = df3.sort_values(["chrom", "start", "cov"], ascending=True).drop_duplicates(keep="last").set_index(["gene_id"])

    return df3[["chrom", "start", "end", "gene_type", "tpm", "state", "cov"]]


def generate_label_mappings(subcomps: pd.DataFrame, labels: List[str]) -> Dict[str, str]:
    """
    Map pretty labels specified through the CLI to labels from the subcompartment bedGraph.
    Mapping is based on label order.
    """
    original_labels = subcomps.filter(regex=r".state$").columns.tolist()
    if len(original_labels) != len(labels):
        raise RuntimeError(f"Expected {len(original_labels)} labels, found {len(labels)}")

    mappings = {k.removesuffix(".state"): v for k, v in zip(original_labels, labels)}
    logging.info("Label mappings: %s", mappings)
    return mappings


def rename_subcompartment_conditions(subcomps: pd.DataFrame, label_mappings: Dict[str, str]) -> pd.DataFrame:
    logging.info("Renaming conditions in subcompartment df...")
    df = subcomps.rename(columns={f"{k}.state": v for k, v in label_mappings.items()})
    df = df.rename(columns={f"{k}.freq": v for k, v in label_mappings.items()})
    return df


def rename_marker_conditions(marker_table: pd.DataFrame, label_mappings: Dict[str, str]) -> pd.DataFrame:
    logging.info("Renaming conditions in marker df...")
    df = marker_table.copy().reset_index()

    df["condition"] = df["condition"].map(label_mappings)
    assert not df["condition"].hasnans

    return df.set_index(marker_table.index.names)


def plot_boxplots(dfs: Dict[str, pd.DataFrame], yscale: str, gene_type: Union[str, None] = None) -> plt.Figure:
    logging.info("Plotting %s genes...", "all" if gene_type is None else gene_type)
    fig, axs = plt.subplots(1, len(dfs), figsize=(6.4 * len(dfs), 6.4), sharey=True)
    ylim_ub = 0
    for ax, (condition, df) in zip(axs, dfs.items()):
        if gene_type is not None:
            df = df.copy()[df["gene_type"] == gene_type]

        sns.boxplot(
            df,
            x="state",
            y="tpm",
            ax=ax,
            order=get_subcompartment_ranks().keys(),
            palette="coolwarm",
            bootstrap=10000,
        )
        ax.set(title=condition)

        sizes = df.groupby("state").size().to_dict()
        legend = "" if gene_type is None else f"{gene_type}\n"
        for k in get_subcompartment_ranks().keys():
            legend += f"{k}: {sizes.get(k, 0)}\n"
        ax.add_artist(AnchoredText(legend.strip(), loc="upper left"))

        ylim_ub = max(ylim_ub, ax.get_ylim()[-1])

    with warnings.catch_warnings():
        # Ignore warnings about 0 values and log-scale
        warnings.filterwarnings("ignore", category=UserWarning)
        for ax in axs:
            ax.set(
                xlabel="Subcompartment state",
                ylabel="TPM",
                yscale=yscale,
                ylim=(0, ylim_ub),
            )
            ax.tick_params(axis="x", which="both", length=0)  # Hide xticks but keep showning labels
            # ax.grid(True, which="both", ls="-")

    return fig


def save_plot_to_file(fig: plt.Figure, outprefix: pathlib.Path, force: bool, close_after_save: bool = True) -> None:
    png = outprefix.with_suffix(".png")
    svg = outprefix.with_suffix(".svg")
    if not force:
        handle_path_collisions(png, svg)

    fig.savefig(png, bbox_inches="tight", dpi=300)
    fig.savefig(svg, bbox_inches="tight")
    if close_after_save:
        plt.close(fig)


def setup_logger(level=logging.INFO):
    fmt = "[%(asctime)s] %(levelname)s: %(message)s"
    logging.basicConfig(format=fmt)
    logging.getLogger().setLevel(level)


def main():
    args = vars(make_cli().parse_args())

    subcomps = import_subcomps(args["bedgraph"])

    labels = args["labels"]
    if labels is None:
        labels = subcomps.columns.tolist()
    elif len(labels) != len(subcomps.columns):
        raise RuntimeError(f"Expected {len(subcomps.columns)} labels, found {len(labels)}")

    gtf = import_gtf(args["gtf"])
    sample_name_mappings = import_sample_name_mappings(args["sample_name_mappings_tsv"])
    expression_table = import_expression_table(args["expression-table"], gtf, sample_name_mappings)

    dfs = {
        label: overlap_genes_with_subcompartments(expression_table, subcomps[col])
        for label, col in zip(labels, subcomps)
    }
    output_prefix = args["output-prefix"]

    fig = plot_boxplots(dfs, yscale=args["yscale"])
    fig.suptitle("All genes")
    save_plot_to_file(fig, pathlib.Path(f"{output_prefix}_all"), args["force"])

    for gene_type in extract_gene_types(dfs.values()):
        fig = plot_boxplots(dfs, gene_type=gene_type, yscale=args["yscale"])
        fig.suptitle(gene_type)
        save_plot_to_file(fig, pathlib.Path(f"{output_prefix}_{gene_type.lower()}"), args["force"])


if __name__ == "__main__":
    setup_logger()
    main()
