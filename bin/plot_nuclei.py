#!/usr/bin/env python3

# Copyright (C) 2024 Roberto Rossini <roberros@uio.no>
#
# SPDX-License-Identifier: MIT

import argparse
import itertools
import os
import pathlib
import sys
from typing import Any, Dict, List, Union

import h5py
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages


def make_cli():
    def positive_int(arg):
        if (n := int(arg)) > 0:
            return n

        raise ValueError("Not a positive integer")

    cli = argparse.ArgumentParser()

    cli.add_argument(
        "URI",
        type=str,
        help="HDF5 URI to a figure generated by one of the scripts in this repository.",
    )

    cli.add_argument(
        "-o",
        "--output",
        type=pathlib.Path,
        required=True,
        help="Path where to save the extracted image.",
    )

    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Overwrite existing files (if any).",
    )

    cli.add_argument(
        "--plot-blobs",
        action="store_true",
        default=False,
        help="Overlay blobs on top of the original image.",
    )

    cli.add_argument(
        "--channel",
        choices={"RGB", "R", "G", "B"},
        default="RGB",
        help="Image channels to be plotted.",
    )

    cli.add_argument(
        "--overlap-cfx-cutoff",
        default=0.0,
        type=float,
        help="Overlap coefficient cutoff used to filter out nuclei whose shape diverges from that of an ellipsis.",
    )

    cli.add_argument(
        "--dpi",
        type=positive_int,
        default=300,
        help="Figure DPI.",
    )

    return cli


def import_blobs(grp: Union[h5py.Group, None], color: str) -> Union[pd.DataFrame, None]:
    if grp is None:
        return None

    return pd.DataFrame({"x": grp[f"{color}/x"][:], "y": grp[f"{color}/y"][:]})


def plot_many(
    images_h5: List[h5py.Dataset],
    blobs_h5: List[Union[h5py.Group, None]],
    channel: str,
    plot_blobs: bool,
) -> plt.Figure:
    cols = 4
    rows = max(1, int(np.ceil(len(images_h5) / cols)))
    fig1, axs = plt.subplots(rows, cols, figsize=(6.4 * cols, 6.4 * rows))

    try:
        _ = next(itertools.chain(*axs))
    except:
        axs = [axs]

    for ax in itertools.chain(*axs):
        ax.axis("off")

    if len(images_h5) != 1:
        blobs_h5 = [None] + blobs_h5

    for img_dset, blobs_grp, ax in zip(images_h5, blobs_h5, itertools.chain(*axs)):
        if img_dset is None:
            print("Skipping image...", file=sys.stderr)
            continue
        img = img_dset[:]
        red_blobs = import_blobs(blobs_grp, color="red")
        green_blobs = import_blobs(blobs_grp, color="green") if plot_blobs else None
        if channel == "R":
            print("Plotting RED channel...", file=sys.stderr)
            ax.imshow(img[:, 0], cmap="Reds")
        elif channel == "G":
            print("Plotting GREEN channel...", file=sys.stderr)
            ax.imshow(img[:, 1], cmap="Greens")
        elif channel == "B":
            print("Plotting BLUE channel...", file=sys.stderr)
            ax.imshow(img[:, 2], cmap="Blues")
        else:
            print("Plotting RGB image...", file=sys.stderr)
            ax.imshow(img)

        if red_blobs is not None:
            print("Plotting red blobs...", file=sys.stderr)
            ax.scatter(
                red_blobs["x"],
                red_blobs["y"],
                s=20,
                color="red",
                edgecolors="white",
                linewidth=1,
            )

        if green_blobs is not None:
            print("Plotting green blobs...", file=sys.stderr)
            ax.scatter(
                green_blobs["x"],
                green_blobs["y"],
                s=20,
                color="green",
                edgecolors="white",
                linewidth=1,
            )

    fig1.tight_layout()
    return fig1


def process_one_image(uri: str, args: Dict[str, Any]) -> plt.Figure:
    file_path, _, hdf5_path = uri.partition("::")
    hdf5_img_path = f"{hdf5_path}/imgs/"
    hdf5_blobs_path = f"{hdf5_path}/blobs/"

    with h5py.File(file_path) as h5:
        obj = h5.get(hdf5_img_path)
        is_dataset = isinstance(obj, h5py.Dataset)

        if obj is None:
            raise RuntimeError(f"Object does not exist: {hdf5_img_path}")

        if is_dataset:
            img_objects = [obj]
            blobs_objects = [h5.get(hdf5_blobs_path) if args["plot_blobs"] else None]
        else:
            assert isinstance(obj, h5py.Group)
            img_objects = [h5[f"{hdf5_img_path}/{grp}"] for grp in obj]
            if args["plot_blobs"]:
                blobs_objects = [h5.get(f"{hdf5_blobs_path}/{dset}") for dset in h5.get(hdf5_blobs_path)]
            else:
                blobs_objects = [None] * len(img_objects)

            scores = h5[f"{hdf5_path}/scores"][:]

            for i, score in enumerate(scores):
                if score < args["overlap_cfx_cutoff"]:
                    img_objects[i + 1] = None
                    blobs_objects[i] = None

        fig = plot_many(img_objects, blobs_objects, args["channel"], args["plot_blobs"])

        return fig


def main():
    args = vars(make_cli().parse_args())

    output = args["output"]
    if not args["force"] and os.path.exists(output):
        raise RuntimeError(f'Refusing to overwrite output file "{output}"')

    file_path, _, hdf5_path = args["URI"].partition("::")

    if hdf5_path != "":
        fig = process_one_image(args["URI"], args)
        fig.tight_layout()
        fig.savefig(args["output"], dpi=args["dpi"])
        return

    if str(args["output"]).split(".")[-1] != "pdf":
        raise RuntimeError("Output format should be PDF when plotting multiple images at once.")

    with PdfPages(args["output"]) as pdf:
        with h5py.File(file_path) as h5:
            for grp in h5:
                fig = process_one_image(f"{file_path}::/{grp}", args)
                fig.suptitle(grp)
                fig.tight_layout()
                pdf.savefig(fig, dpi=args["dpi"])
                plt.close(fig)


if __name__ == "__main__":
    main()
