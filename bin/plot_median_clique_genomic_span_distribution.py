#!/usr/bin/env python3

# Copyright (C) 2024 Roberto Rossini <roberros@uio.no>
# SPDX-License-Identifier: MIT


import argparse
import pathlib
from typing import Iterable, List, Union

import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns


def make_cli() -> argparse.ArgumentParser:
    def existing_file(arg):
        if (file := pathlib.Path(arg)).exists():
            return file

        raise FileNotFoundError(arg)

    cli = argparse.ArgumentParser()

    cli.add_argument(
        "--cliques",
        nargs="+",
        type=existing_file,
        help="Path to one or more clique TSV file(s) generated by robomics/call_tad_cliques.",
    )
    cli.add_argument(
        "--domains",
        nargs="+",
        type=existing_file,
        help="Path to one or more domain BED file(s) generated by robomics/call_tad_cliques.",
    )
    cli.add_argument(
        "-o",
        "--output-name",
        required=True,
        type=pathlib.Path,
        help="Path to output.",
    )
    cli.add_argument(
        "--labels",
        type=str,
        help="Comma separated list of sample labels to use for plotting.\n"
        "When not provided, labels are inferred from input file names.",
    )

    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Force overwrite existing files.",
    )

    return cli


def handle_path_collisions(*paths: pathlib.Path) -> None:
    collisions = [p for p in paths if p.exists()]

    if len(collisions) != 0:
        collisions = "\n - ".join((str(p) for p in collisions))
        raise RuntimeError(
            "Refusing to overwrite file(s):\n" f" - {collisions}\n" "Pass --force to overwrite existing file(s)."
        )


def save_plot_to_file(fig: plt.Figure, outprefix: pathlib.Path, force: bool, close_after_save: bool = True) -> None:
    outprefix = pathlib.Path(outprefix)
    png = outprefix.with_suffix(".png")
    svg = outprefix.with_suffix(".svg")
    if not force:
        handle_path_collisions(png, svg)

    outprefix.parent.mkdir(exist_ok=True, parents=True)

    fig.savefig(png, bbox_inches="tight", dpi=300)
    fig.savefig(svg, bbox_inches="tight")
    if close_after_save:
        plt.close(fig)


def import_cliques(path_to_cliques: Union[pathlib.Path, None]) -> Union[pd.DataFrame, None]:
    if path_to_cliques is None:
        return None
    df = pd.read_table(path_to_cliques).rename(columns={"name": "clique"})
    assert df.columns.tolist() == ["clique", "tad_ids", "size"]
    df["tad_ids"] = df["tad_ids"].apply(lambda ids: [int(tid) for tid in ids.split(",")])
    return df.rename(columns={"clique": "name"})


def import_data(cliques: List[str], domains: List[str], labels: List[str]) -> pd.DataFrame:
    assert len(cliques) == len(domains)
    assert len(cliques) == len(labels)

    dfs = []
    for cliques, domains, label in zip(cliques, domains, labels):
        df1 = import_cliques(cliques)
        df2 = pd.read_table(domains, names=["chrom", "start", "end", "id"])

        df1 = df1.explode("tad_ids").rename(columns={"tad_ids": "tad_id"})
        df1["tad_id"] = df1["tad_id"].astype(int)
        df1 = df1.merge(df2, left_on="tad_id", right_on="id").drop(columns="id")

        df1["condition"] = label
        dfs.append(df1)

    return pd.concat(dfs).sort_values(["condition", "name"])


def generate_labels(paths: Iterable[pathlib.Path]) -> List[str]:
    labels = []
    for p in paths:
        labels.append(str(p.name).rstrip("".join(p.suffixes)))

    return labels


def compute_clique_stats(df: pd.DataFrame) -> pd.DataFrame:
    data = []
    for (condition, clique), df in df.groupby(["condition", "name"]):
        df = df[["chrom", "start", "end"]]
        size = len(df)

        df = df.merge(df, how="cross", suffixes=("1", "2"))
        df = df[df["start1"] < df["start2"]]
        df["distance"] = (((df["start1"] + df["end1"]) / 2) - ((df["start2"] + df["end2"]) / 2)).abs()

        mean = df["distance"].mean()
        median = df["distance"].median()
        std = df["distance"].std()

        data.append([condition, clique, median, mean, std, size])

    return pd.DataFrame(data, columns=["condition", "clique", "median_dist", "mean_dist", "std_dist", "clique_size"])


def main():
    args = vars(make_cli().parse_args())

    path_to_cliques = args["cliques"]
    path_to_domains = args["domains"]
    labels = args.get("labels")

    if labels is None:
        labels = generate_labels(path_to_domains)
    else:
        labels = labels.split(",")

    if len(path_to_cliques) != len(path_to_domains):
        raise RuntimeError(f"Expected {len(path_to_cliques)} domain files, found {len(path_to_domains)}")

    if len(labels) != len(path_to_domains):
        raise RuntimeError(f"Expected {len(path_to_domains)} labels, found {len(labels)}")

    df = import_data(path_to_cliques, path_to_domains, labels)
    stats = compute_clique_stats(df)

    fig, ax = plt.subplots(1, 1, figsize=(20, 10))
    sns.boxplot(stats, x="clique_size", y="median_dist", hue="condition", ax=ax)

    outname = pathlib.Path(str(args["output_name"]))

    if not args["force"]:
        handle_path_collisions(outname)

    outname.parent.mkdir(exist_ok=True, parents=True)
    fig.savefig(outname, bbox_inches="tight", dpi=300)


if __name__ == "__main__":
    mpl.rcParams.update(
        {
            "axes.titlesize": 10,
            "axes.labelsize": 22,
            "legend.fontsize": 17,
            "xtick.labelsize": 18,
            "ytick.labelsize": 18,
        }
    )
    main()
