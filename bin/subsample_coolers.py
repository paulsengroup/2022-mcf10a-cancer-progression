#!/usr/bin/env python3

# Copyright (C) 2023 Roberto Rossini <roberros@uio.no>
#
# SPDX-License-Identifier: MIT

import argparse
import hashlib
import itertools
import logging
import multiprocessing as mp
import pathlib
from typing import Dict, List, Union

import cooler
import cooltools
import h5py
import numpy as np


def make_cli():
    cli = argparse.ArgumentParser()

    cli.add_argument(
        "coolers",
        type=pathlib.Path,
        nargs="+",
        help="Path to two or more cooler files (URI syntax supported).",
    )
    cli.add_argument(
        "--output-names",
        type=pathlib.Path,
        nargs="+",
        help="Output names (one for each input).\n"
        'By default output names are generated by adding suffix "_subsampl" to input file names.',
    )
    # cli.add_argument("--keep-weights", action="store_true", default=False, help="Keep balancing weights.")
    cli.add_argument(
        "--cis-only",
        action="store_true",
        default=False,
        help="Use cis insteractions only to compute the subsampling fraction.",
    )
    cli.add_argument("--seed", type=int, default=1595040562, help="Seed for PRNG initialization.")
    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Overwrite existing files (if any).",
    )
    cli.add_argument(
        "--nproc",
        type=int,
        choices=range(1, mp.cpu_count() + 1),
        default=mp.cpu_count(),
        help="Maximum number of parallel processes.",
    )
    return cli


def parse_cooler_uri(uri):
    cf = cooler.Cooler(uri)
    return cf.filename, cf.root.lstrip("/")


def generate_output_names(uris: List[pathlib.Path], suffix: str = "_subsampl") -> List[pathlib.Path]:
    output_names = []
    for uri in uris:
        fname = pathlib.Path(cooler.Cooler(str(uri)).filename)
        prefix = str(pathlib.Path(fname).with_suffix(""))
        output_names.append(pathlib.Path(prefix + suffix).with_suffix(".cool"))

    return output_names


def read_or_compute_sum(uri: str, cis_only: bool, pool) -> int:
    cf = cooler.Cooler(uri)
    if cis_only:
        return cf.info.get(
            "cis",
            np.sum(cooltools.api.coverage.coverage(cf, map=pool.map)[0] // 2, dtype=int),
        )

    return cf.info.get(
        "sum",
        np.sum(cooltools.api.coverage.coverage(cf, map=pool.map)[1] // 2, dtype=int),
    )


def compute_number_of_interactions(uris: List[pathlib.Path], cis_only: bool, pool) -> Dict[str, Union[int]]:
    return {uri: read_or_compute_sum(str(uri), cis_only, pool) for uri in uris}


def remove_weight_datasets(uri):
    fname, suffix = parse_cooler_uri(uri)
    with h5py.File(fname, "r+") as cf:
        for dset in cf[f"{suffix}/bins"].keys():
            if dset not in {"chrom", "start", "end"}:
                del cf[f"{suffix}/bins"][dset]


def cooltools_sample(
    input_uri: str,
    output_uri: str,
    target_interactions: Union[int, float],
    cis_only: bool,
    uri_with_fewer_interactions: str,
    seed: int,
):
    assert input_uri != output_uri
    if input_uri == uri_with_fewer_interactions:
        logging.info("Copying %s to %s...", input_uri, output_uri)
        pathlib.Path(output_uri).unlink(missing_ok=True)
        cooler.fileops.cp(input_uri, output_uri)
        remove_weight_datasets(output_uri)
        return

    target_interactions_cis = None
    if cis_only:
        target_interactions_cis = target_interactions
        target_interactions = None

    seed = (input_uri + str(seed)).encode("utf-8")
    seed = int(hashlib.sha256(seed).hexdigest(), 16) % (2**32 - 1)
    np.random.seed(seed)  # TODO: I am not sure how PRNG and chunking works

    logging.info("Subsampling interactions from %s", input_uri)
    cooltools.api.sample.sample(
        input_uri,
        output_uri,
        count=target_interactions,
        cis_count=target_interactions_cis,
    )
    logging.info(
        "Written %s interactions to %s",
        str(cooler.Cooler(output_uri).info.get("sum")),
        output_uri,
    )


def main():
    args = vars(make_cli().parse_args())
    input_coolers = args["coolers"]

    if args.get("output_names") is None:
        args["output_names"] = generate_output_names(input_coolers)

    output_coolers = args["output_names"]
    if len(input_coolers) != len(output_coolers):
        raise RuntimeError(
            f"Mismatch in the number of input and output files: {len(input_coolers)} inputs and {len(output_coolers)} outputs."
        )

    if not args["force"]:
        for path in output_coolers:
            if path.exists():
                raise RuntimeError(f"Refusing to overwrite file {path}. Pass --force to overwrite existing file(s).")

    with mp.Pool(min(args["nproc"], len(input_coolers))) as pool:
        number_of_interactions = compute_number_of_interactions(input_coolers, args["cis_only"], pool)

        target_number_of_interactions = None
        for uri, interactions in number_of_interactions.items():
            if target_number_of_interactions is None or interactions < target_number_of_interactions:
                target_number_of_interactions = interactions
                uri_with_fewer_interactions = uri

        logging.info(
            "Subsampling to (approximately) %d interactions",
            int(target_number_of_interactions),
        )
        pool.starmap(
            cooltools_sample,
            zip(
                (str(uri) for uri in input_coolers),
                (str(uri) for uri in output_coolers),
                itertools.repeat(target_number_of_interactions),
                itertools.repeat(args["cis_only"]),
                itertools.repeat(str(uri_with_fewer_interactions)),
                itertools.repeat(args["seed"]),
            ),
        )


def setup_logger(level=logging.INFO):
    fmt = "[%(asctime)s] %(levelname)s: %(message)s"
    logging.basicConfig(format=fmt)
    logging.getLogger().setLevel(level)

    for h in logging.getLogger("cooltools").handlers:
        h.setFormatter(logging.Formatter(fmt))

    logging.getLogger("cooltools.sample").setLevel(level)


if __name__ == "__main__":
    setup_logger()
    main()
