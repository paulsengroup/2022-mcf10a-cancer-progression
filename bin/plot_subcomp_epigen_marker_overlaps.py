#!/usr/bin/env python3

# Copyright (C) 2023 Roberto Rossini <roberros@uio.no>
#
# SPDX-License-Identifier: MIT

import argparse
import logging
import pathlib
import warnings
from typing import Tuple

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


def make_cli():
    def existing_file(arg):
        if (path := pathlib.Path(arg)).exists():
            return path

        raise FileNotFoundError(f'File "{arg}" does not exists')

    cli = argparse.ArgumentParser()

    cli.add_argument(
        "table",
        type=existing_file,
        help="Path to the .pickle file generated by overlap_subcomps_with_epigen_markers.py.",
    )

    cli.add_argument(
        "output-prefix",
        type=pathlib.Path,
        help="Path to output prefix (including parent folder(s) but without extension).",
    )

    cli.add_argument(
        "--rescale",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Rescale values based on inteval span.",
    )
    cli.add_argument(
        "--relative",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Normalize values such that rows sum up to 1.",
    )
    cli.add_argument(
        "--aggregation-method",
        type=str,
        choices={"sum", "mean", "median"},
        default="mean",
        help="Aggregation function to use when grouping scores by subcompartment.",
    )

    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Force overwrite existing files.",
    )

    return cli


def handle_path_collisions(*paths: pathlib.Path) -> None:
    collisions = [p for p in paths if p.exists()]

    if len(collisions) != 0:
        collisions = "\n - ".join((str(p) for p in collisions))
        raise RuntimeError(
            "Refusing to overwrite file(s):\n" f" - {collisions}\n" "Pass --force to overwrite existing file(s)."
        )


def import_table(path_to_table: pathlib.Path) -> pd.DataFrame:
    logging.info("Reading table from %s...", path_to_table)
    return pd.read_pickle(path_to_table)


def min_max_scaler(data: np.ndarray) -> np.ndarray:
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=RuntimeWarning)
        # Suppress warnings regarding division by 0/nan
        min_ = np.min(data, axis=1)[:, None]
        max_ = np.max(data, axis=1)[:, None]

        return (data - min_) / (max_ - min_)


def plot_heatmap(
    data: np.ndarray,
    relative: bool,
    ax: plt.Axes,
    subcompartment_labels: Tuple[str],
    markers: Tuple[str],
    cmap="Reds",
) -> None:
    # Rescale values such that the smallest value in each row has the same dynamic range
    scaled_data = min_max_scaler(data)
    ax.imshow(scaled_data, cmap=cmap)

    if relative:
        logging.info("Rescaling rows...")
        # Make values in each row sum to 1
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=RuntimeWarning)
            # Suppress warnings regarding division by 0/nan
            scaling_factors = np.sum(data, axis=1)[:, None]
            data = data / scaling_factors

    for (j, i), label in np.ndenumerate(data):
        if np.isnan(label):
            continue
        scaled_label = scaled_data[j, i]

        if scaled_label >= 0.65 * scaled_data[j].max():
            color = "white"
        else:
            color = "black"
        ax.text(i, j, f"{label:.3f}", ha="center", va="center", color=color)

    ax.set_xticks(range(len(subcompartment_labels)))
    ax.set_yticks(range(len(markers)))

    ax.set_xticklabels(subcompartment_labels)
    ax.set_yticklabels(markers)


def plot_heatmaps(df: pd.DataFrame, relative: bool, aggregation_method: str = "mean") -> plt.Figure:
    subcompartment_labels = tuple(["B3", "B2", "B1", "B0", "A0", "A1", "A2", "A3"])
    conditions = df.columns.get_level_values(0).unique().tolist()
    markers = df[conditions[0]].drop(columns=["subcompartment"]).columns.tolist()

    row = df.index.to_frame().iloc[0]
    resolution = row["end"] - row["start"]

    w = 1 * len(conditions) * len(subcompartment_labels)
    h = 1 * len(markers)

    fig, axs = plt.subplots(1, len(conditions), figsize=(w, h), sharey=True)
    fig.suptitle(f"Subcompartments vs epigenetic markers ({resolution})")

    for ax, cond in zip(axs, conditions):
        logging.info("[%s] Plotting heatmap...", cond)

        ax.set(title=f"{cond}")

        if aggregation_method == "mean":
            data = df.loc[:, (cond)].groupby("subcompartment").mean().reindex(subcompartment_labels)
        elif aggregation_method == "median":
            data = df.loc[:, (cond)].groupby("subcompartment").median().reindex(subcompartment_labels)
        else:
            assert aggregation_method == "sum"
            data = df.loc[:, (cond)].groupby("subcompartment").sum().reindex(subcompartment_labels)

        data = np.array(data, dtype=float).T

        plot_heatmap(data, relative, ax, subcompartment_labels, markers)

    for ax in axs[1:]:
        ax.tick_params(axis="y", which="both", left=False)

    plt.subplots_adjust(wspace=0, hspace=0)

    return fig


def setup_logger(level=logging.INFO):
    fmt = "[%(asctime)s] %(levelname)s: %(message)s"
    logging.basicConfig(format=fmt)
    logging.getLogger().setLevel(level)


def main():
    args = vars(make_cli().parse_args())

    output_prefix = args["output-prefix"]
    if not args["force"]:
        handle_path_collisions(*(output_prefix.with_suffix(ext) for ext in (".png", ".svg")))

    df = import_table(args["table"])

    if args["rescale"]:
        logging.info("Rescaling values...")
        spans = df.index.get_level_values("end") - df.index.get_level_values("start")
        df = df.apply(lambda col: col / spans if pd.api.types.is_numeric_dtype(col) else col)

    fig = plot_heatmaps(df, args["relative"], args["aggregation_method"])
    plt.tight_layout()

    logging.info("Writing plots to to %s.{png,svg}...", output_prefix)
    output_prefix.parent.mkdir(exist_ok=True, parents=True)
    fig.savefig(output_prefix.with_suffix(".png"), dpi=600)
    fig.savefig(output_prefix.with_suffix(".svg"))


if __name__ == "__main__":
    setup_logger()
    main()
