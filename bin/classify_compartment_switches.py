#!/usr/bin/env python3


# Copyright (C) 2023 Roberto Rossini <roberros@uio.no>
#
# SPDX-License-Identifier: MIT

import argparse
import functools
import pathlib
import warnings
from collections import Counter
from typing import Tuple

import bioframe as bf
import matplotlib.pyplot as plt
import matplotlib_venn
import numpy as np
import numpy.typing as npt
import pandas as pd
from matplotlib import colors
from matplotlib.patches import Patch


def make_cli():
    def existing_file(arg):
        if (path := pathlib.Path(arg)).exists():
            return path

        raise FileNotFoundError(f'File "{arg}" does not exists')

    cli = argparse.ArgumentParser()

    def positive_int(arg):
        if (n := int(arg)) > 0:
            return n

        raise ValueError("Not a positive integer")

    cli.add_argument(
        "bedgraph",
        type=existing_file,
        help="Path to the (sub)compartment bedGraph generated by dcHiC.",
    )

    cli.add_argument(
        "-o",
        "--output-prefix",
        type=pathlib.Path,
        help="Output prefix.",
    )
    cli.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Overwrite existing files (if any).",
    )

    return cli


@functools.cache
def get_subcompartment_ranks() -> dict:
    compartment_labels = tuple(["B3", "B2", "B1", "B0", "A0", "A1", "A2", "A3"])
    return {k: v for v, k in enumerate(compartment_labels)}


@functools.cache
def get_compartment_ranks() -> dict:
    compartment_labels = tuple(["B", "A"])
    return {k: v for v, k in enumerate(compartment_labels)}


def handle_path_collisions(*paths: pathlib.Path) -> None:
    collisions = [p for p in paths if p.exists()]

    if len(collisions) != 0:
        collisions = "\n - ".join((str(p) for p in collisions))
        raise RuntimeError(
            "Refusing to overwrite file(s):\n" f" - {collisions}\n" "Pass --force to overwrite existing file(s)."
        )


def save_plot_to_file(fig: plt.Figure, outprefix: pathlib.Path, force: bool, close_after_save: bool = True) -> None:
    png = outprefix.with_suffix(".png")
    svg = outprefix.with_suffix(".svg")
    if not force:
        handle_path_collisions(png, svg)

    fig.savefig(png, bbox_inches="tight", dpi=300)
    fig.savefig(svg, bbox_inches="tight")
    if close_after_save:
        plt.close(fig)


def import_subcompartments(bedgraph: pathlib.Path) -> npt.NDArray:
    df = pd.read_table(bedgraph).set_index(bf.SCHEMAS["bed3"]).filter(regex=r".*state.*")
    df.columns = ["WT", "T1", "C1", "mode"]
    df = map_subcomps_to_rank_matrix(df)
    return df.drop(columns="mode").to_numpy()


def map_subcomps_to_rank_matrix(df: pd.DataFrame) -> pd.DataFrame:
    for col in df.columns:
        df[col] = df[col].map(get_subcompartment_ranks())
    return df


def classify_transitions(
    m,
) -> Tuple[npt.NDArray, npt.NDArray, npt.NDArray, npt.NDArray, npt.NDArray]:
    neutral = np.full_like(m[:, 0], True, dtype=bool)
    fully_reverted = (m[:, 0] != m[:, 1]) & (m[:, 0] == m[:, 2])
    for i in range(m.shape[1]):
        neutral &= m[:, 0] == m[:, i]
    monotonically_increasing = (~neutral) & (np.all(m[:, 1:] >= m[:, :-1], axis=1))
    monotonically_decreasing = (~neutral) & (np.all(m[:, 1:] <= m[:, :-1], axis=1))

    other = (~fully_reverted) & (~monotonically_decreasing) & (~monotonically_increasing) & (~neutral)

    return (
        neutral,
        fully_reverted,
        monotonically_decreasing,
        monotonically_increasing,
        other,
    )


def plot_transition_piechart(
    neutral: npt.NDArray,
    fully_reverted: npt.NDArray,
    monotonically_decreasing: npt.NDArray,
    monotonically_increasing: npt.NDArray,
    other: npt.NDArray,
    ax: plt.Axes,
):
    data = {
        "neutral": neutral.sum(),
        "reverted": fully_reverted.sum(),
        "transition to open": monotonically_decreasing.sum(),
        "transition to close": monotonically_increasing.sum(),
        "other": other.sum(),
    }

    ax.pie(list(data.values()), labels=list(data.keys()), autopct="%.2f %%")


def plot_composition_piechart(
    matrix: npt.NDArray,
    monotonically_decreasing: npt.NDArray,
    monotonically_increasing: npt.NDArray,
    ax: plt.Axes,
):
    m1 = matrix[monotonically_increasing | monotonically_decreasing]
    delta1 = m1[:, 2] - m1[:, 0]
    deltas = Counter((n for n in delta1))
    data = list(deltas.values())

    max_delta = max((abs(x) for x in deltas.keys()))
    cmap = plt.get_cmap("bwr")

    delta_to_colors = {
        i: colors.to_hex(x)
        for i, x in zip(
            range(-max_delta, max_delta + 1),
            cmap(np.linspace(0, 1, 1 + max_delta * 2)).tolist(),
        )
    }
    colors_to_delta = {v: k for k, v in delta_to_colors.items()}

    colors_ = []
    for delta in deltas.keys():
        colors_.append(delta_to_colors[delta])

    colors_ = [x for _, x in sorted(zip(data, colors_))]
    data = np.sort(data)

    _ = plt.pie(data, colors=colors_)

    legend_elements = []
    for c in sorted(colors_, key=lambda c: colors_to_delta[c]):
        delta = colors_to_delta[c]
        magnitude = deltas[delta]
        legend_elements.append(Patch(facecolor=c, label=f"{delta} ({magnitude} bins)"))

    ax.legend(handles=legend_elements, bbox_to_anchor=(1, 1))


def main():
    args = vars(make_cli().parse_args())

    m = import_subcompartments(args["bedgraph"])

    (
        neutral,
        fully_reverted,
        monotonically_decreasing,
        monotonically_increasing,
        other,
    ) = classify_transitions(m)

    data = {
        "neutral": neutral.sum(),
        "reverted": fully_reverted.sum(),
        "transition to open": monotonically_decreasing.sum(),
        "transition to close": monotonically_increasing.sum(),
        "other": other.sum(),
    }

    fig, axs = plt.subplots(1, 2, figsize=(6.4 * 2, 6.4))
    plot_transition_piechart(
        neutral,
        fully_reverted,
        monotonically_decreasing,
        monotonically_increasing,
        other,
        axs[0],
    )
    plot_composition_piechart(m, monotonically_decreasing, monotonically_increasing, axs[1])

    save_plot_to_file(fig, args["output_prefix"], args["force"])


if __name__ == "__main__":
    main()
